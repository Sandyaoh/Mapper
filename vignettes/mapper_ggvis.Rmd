---
title: "Using Mapper for Projection Pursuit"
output: html_notebook
---

This is part 2 of a multi-part tutorial series demonstrating both the utility and generality of the _Mapper_ method. This vignette describes how one might use the _Mapper_ package to do _exploratory data analysis_ of multivariate data. 

## Intro

Multivariate data are often viewed as multiple indirect measurements arising from an underlying source. Generally, it's also assumed this source consists of hidden or unobserved variables which cannot be directly measured.


```{r}
data("banknote", package = "mclust")
X <- banknote[,2:7]
n <- nrow(X)
A <- t(with(structure(svd(X), names=c("d", "U", "V")), {
  D <- diag(d)
  S <- sqrt(n)*U
  A <- D %*% t(V)/sqrt(n)
  S %*% t(A)
}))
```



Counterfeit Swiss banknote data

```{r}
data("banknote", package = "mclust")
plot(banknote[,2:7], col = banknote$Status)
```

Enter _projection pursuit_ (PP). The basic idea of PP is to define a projection index (I) which conveys how 'interesting'
a given planar projection of the data is. One usually starts with orthogonal vectors $u, v, \dots$ and then uses some optimization method to find the plane maximizing that index. 

```{r}
mu <- replicate(3, runif(3, min = 1, max = 50))
X <- do.call(rbind, lapply(seq(nrow(mu)), function(i){
  sigma <- diag(sample(c(15, 20, 25), size = 3, replace = TRUE))
  MASS::mvrnorm(mu = mu[i,], Sigma = sigma, n = 1000)
}))
rgl::plot3d(X, col = rep(seq(nrow(mu)), each = 100))
```

The grand tour
```{r}

library(shiny)
library(ggvis)
library(tourr)
gtour <- function(data, groups) {
  aps <- 2 # angular velocity
  fps <- 30
  mat <- rescale(as.matrix(data))
  tour <- new_tour(mat, grand_tour(), NULL)
  start <- tour(0)
  proj_data <- reactive({
    invalidateLater(1000 / fps, NULL);
    step <- tour(aps / fps)
    data.frame(center(mat %*% step$proj), groups = groups)
  })
  proj_data %>% ggvis(~X1, ~X2, fill = ~groups) %>%
    layer_points() %>%
    scale_numeric("x", domain = c(-1, 1)) %>%
    scale_numeric("y", domain = c(-1, 1)) %>%
    add_axis("x", title = "") %>% add_axis("y", title = "") %>%
    set_options(duration = 0)
}
gtour(data = bn, groups = banknote$Status)

gtour(X, groups = rep(1:3, each = 1000))
```

tour, as a parallel coordinate plot 

```{r}
tour_pcp <- function(data, groups, d = 2L) {
  aps <- 1.1; fps <- 30
  mat <- rescale(as.matrix(data))
  tour <- new_tour(mat, little_tour(d), NULL)
  start <- tour(0)
  idx <- rep(seq(nrow(data)), d)
  dim <- as.factor(rep(sprintf("d%d", seq(d)), each=nrow(data)))
  group <- rep(groups, d)
  n_grps <- length(unique(groups))
  g_color <- rainbow(n_grps)[match(groups, seq(n_grps))][groups]
  dat <- data.table::data.table(dim=dim, value=vector(mode="numeric", length(idx)), idx=idx, col=g_color)
  xy <- reactive({
    invalidateLater(1000 / fps, NULL);
    step <- tour(aps / fps)
    # data.frame(dim=dim, value=as.vector(center(mat %*% step$proj)), idx=idx, col=g_color)
    dat[, value := as.vector(center(mat %*% step$proj))]
  })
  ggvis(data=xy, x=~dim, y=~value) %>% 
    layer_points() %>%
    scale_numeric("y", domain=c(-1, 1)) %>% 
    group_by(idx) %>% 
    layer_paths(stroke=~col) %>% 
    set_options(duration = 0)
}

## This does not scale very well with the grouping. 
idx_sample <- sample(1:nrow(Xs), size = 20)
tour_pcp(Xs[idx_sample,], groups=groups[idx_sample])

```

Shiny app to do Projection Pursuit w/ Mapper
```{r}
```



```{r}
library("ggvis")
p <- ggvis(mtcars, x = ~wt, y = ~mpg)
layer_points(p)


slider <- input_slider(10, 1000)
data_x <- expand.grid(x=seq(10),y=seq(10))
data_x %>% ggvis(x=~x, y=~y) %>%
  layer_points(fill:="red") %>%
  layer_points(stroke := "black", fill := NA, size := slider)


# x <- reactive({
#   data.frame(x1=rnorm(10), x2=rnorm(10))
# })
x <- data.frame(x1=rnorm(10), x2=rnorm(10))
  # r_t <- matrix(c(cos(90), sin(90), -sin(90), cos(90)), nrow = 2)
  # r_target <- as.matrix(x) %*% r
rotate <- function(X, e){
  if (e == 0){ return(X) }
  if (e >= 1 && e <= 90){
    theta <- e*pi/180
    r <- matrix(c(cos(theta), sin(theta), -sin(theta), cos(theta)), nrow = 2)
    return(t(r %*% t(as.matrix(X))))
  } 
  return(NULL)
}
# class(rotate) <- append(class(rotate), "tour_path")
aps <- 2
fps <- 30
make_counter <- function(start, end, reset=TRUE){
  cc <<- start
  return(function(){
    if (cc >= end){ if(reset) cc <<- start else return(NULL) }
    else { cc <<- cc+1L; return(cc-1L) }
  })
}
counter <- make_counter(0, 90)
proj_data <- reactive({
  invalidateLater(1000 / fps, NULL)
  step <- counter()
  print(step)
  if (!is.null(step)){ return(structure(data.frame(rotate(x, step)), names = c("x1", "x2"))) }
  else { return(NULL) }
})
proj_data %>% 
  ggvis(~x1, ~x2) %>% layer_points() %>% 
  scale_numeric("x", domain = c(-3, 3)) %>%
  scale_numeric("y", domain = c(-3, 3)) %>%
  add_axis("x", title = "") %>% add_axis("y", title = "") %>%
  set_options(duration = 0)

x <- replicate(2, rnorm(100))
cmdscale(dist(x), k = 2)

theta_slider <- input_slider(min = 0, max = 90, value = 0, animate = TRUE)

library(shiny)
library(ggvis)
library(tourr)
gtour <- function(data, groups) {
  aps <- 2 # angular velocity
  fps <- 30
  mat <- rescale(as.matrix(data))
  tour <- new_tour(mat, little_tour(), NULL)
  start <- tour(0)
  proj_data <- reactive({
    invalidateLater(1000 / fps, NULL);
    step <- tour(aps / fps)
    data.frame(center(mat %*% step$proj), groups = groups)
  })
  proj_data %>% ggvis(~X1, ~X2, fill = ~groups) %>%
    layer_points() %>%
    scale_numeric("x", domain = c(-1, 1)) %>%
    scale_numeric("y", domain = c(-1, 1)) %>%
    add_axis("x", title = "") %>% add_axis("y", title = "") %>%
    set_options(duration = 0)
}
gtour(data = bn, groups = banknote$Status)

ggvis::layer_lines()




  ggvis::axis_props()
    lines(adj(cos(theta)), adj(sin(theta)), col = "grey50")
    text(adj(proj[, 1]), adj(proj[, 2]), label = labels, col = "grey50")

apply(, 2, function(xy){ as.list(xy) })
mapply(function(x, y, z, w){
  matrix(c(x, z, y, w), nrow = 2, byrow = FALSE)
}, x0, x1, y0, y1)

    segments(rep(0, 5), rep(0, 5), res$proj[,1], res$proj[,2], col = "grey50")
    theta <- seq(0, 2 * pi, length = 50)
    lines(adj(cos(theta)), adj(sin(theta)), col = "grey50")
    text(res$proj[,1], res$proj[,2], label = abbreviate(colnames(chemdiab[, 1:5])), col = "grey50")

x2 <- rotate(90)$proj
```

```{r}
library("tourr")
data("banknote", package = "mclust")
bn <- rescale(as.matrix(banknote[, 2:7]))

## Adjust 
adj <- local({
  limits <- 1
  axis_scale <- limits/6
  axis_pos <- 0.8
  function(x) axis_pos + x * axis_scale
})


## Base R graphics to show the PP unit-vector projection axes 
res <- tour(100)
plot.new()
plot.window(xlim=c(-1, 1), ylim=c(-1,1), mar=rep(0, 4))
segments(rep(0, 5), rep(0, 5), res$proj[,1], res$proj[,2], col = "grey50")
theta <- seq(0, 2 * pi, length = 50)
lines(cos(theta), sin(theta), col = "grey50")
labels <- abbreviate(colnames(bn), 3)
text(res$proj[, 1], res$proj[, 2], label = labels, col = "grey50", pos = 3)



ggvis::ggvis(data = pp_arrows) %>% 
  layer_paths(~x, ~y) %>% 
  group_by(group) %>% 
  scale_numeric("x", domain = c(-1, 1)) %>%
  scale_numeric("y", domain = c(-1, 1)) %>% 
  layer_paths(data=circle, x=~x, y=~y) %>% 
  layer_text(data=label_xy, text := ~label, x=~x, y=~y)

## This is probably not efficient
# wut <- save_history(bn, little_tour())

ggvis::layer_lines()

tour(2)
```


```{r}
## Load chemical diabetes data set
library(locfit)
data("chemdiab", package = "locfit")

## L-Infinity eccentricity 
X <- tourr::rescale(as.matrix(chemdiab[, -6]))
f_ecc <- matrix(apply(as.matrix(dist(X)), 1, max))

## Make the mapper 
chem_mapper <- function(f_x){
  stopifnot(is.matrix(f_x))
  H <- apply(X, 2, stats::bw.nrd0)
  kde_res <- ks::kde(x = f_x, H = diag(H, nrow = ncol(f_x), ncol = ncol(f_x)), eval.points = f_x, binned = FALSE)
  m <- Mapper::MapperRef$new(X = X)
  m$use_cover(matrix(kde_res$estimate), typename = "fixed rectangular", number_intervals = 8L, percent_overlap = 35)
  m$use_clustering_algorithm(cl = "single", num_bins = 10L)
  m$use_distance_measure(measure = "euclidean")
  m$compute_k_skeleton(k = 1L)
  return(m)
}

loadings <- reshape2::melt(unclass(loadings(pca_chemdiab)))
colnames(loadings) <- c("Dim", "Factor", "Load")
# GPArotation
loadings %>% 
  ggvis(~Dim, ~Factor, fill = ~Load) %>% 
  layer_rects(width = band(), height = band()) %>% 
  scale_nominal("x", padding = 0, points = FALSE) %>%
  scale_nominal("y", padding = 0, points = FALSE)

vc <- colnames(chemdiab[, -6])
ui <- shinyUI(pageWithSidebar(
  headerPanel = headerPanel("\"Visualization is insight; not pictures\""),
  sidebarPanel = sidebarPanel(
    sliderInput("alpha_index", label = "Alpha", min = 0, max = 1, value = 0, step = 1/25, 
                animate = animationOptions(interval=40*2, loop=FALSE)), 
    selectInput("dim1_1", label = "Dim. 1", choices = vc, selected = vc[[1]], width = "30%"), 
    selectInput("dim1_2", label = "Dim. 2", choices = vc, selected = vc[[2]], width = "30%"),
    selectInput("source_dim", label = "Source dim.", choices = vc, selected = vc[[1]], width = "30%"),
    selectInput("target_dim", label = "Target dim.", choices = vc, selected = vc[[3]], width = "30%"),
    actionButton("build_mapper", label = "Build Mapper")
  ), 
  mainPanel = mainPanel(
    rgl::rglwidgetOutput("rgl_out", width = "100%", height = "50%"),
    grapher::grapherOutput("grapher", width = "100%", height = "50%"),
    style = "height: 100vh !important;"
  )
))

server <- shinyServer(function(input, output, session) {
  ## Initialize the scene
  plot3d(rgl_scene)
  
  ## Set callback to appropriately cleanup the RGL session on exit
  dev <- rgl.cur(); save <- options(rgl.inShiny = TRUE)
  on.exit(options(save))
  session$onSessionEnded(function() { rgl.set(dev); rgl.close() })
  
  ## Reactives
  from_dims <- reactive({ c(input$dim1_1, input$dim1_2, input$dim1_3) })
  to_dims <- reactive({ c(input$dim2_1, input$dim2_2, input$dim2_3) })
  cpath <- reactive({
    req(from_dims())
    req(from_dims())
    tourr::geodesic_path(as.matrix(X[, from_dims()]), as.matrix(X[, to_dims()]))
  })
  
  ## Reactive values to stroe the current points
  rgl_react <- reactiveValues()
  rgl_react$data_pts <- NULL # rgl::points3d(tourr::rescale(path$interpolate(0)))
  output$rgl_out <- rgl::renderRglwidget({ 
    rgl_widget <<- rgl::rglwidget()
    return(rgl_widget)
  })
  rgl::plot3d(NULL, xlim = c(0,1), ylim=c(0, 1), zlim=c(0, 1))
  
  ## Render mapper
  output$grapher <- grapher::renderGrapher({
    current_mapper$as_grapher()
  })
  
  ## Observer to modify the projection along a geodesic
  observeEvent(input$alpha_index, {
    # req(input$alpha_index)
    if (!is.null(rgl_react$data_pts)){ rgl::delFromSubscene3d(rgl_react$data_pts) }
    new_pts <- rgl::points3d(tourr::rescale(cpath()$interpolate(input$alpha_index)), color = palette()[chemdiab$cc])
    session$sendCustomMessage(
      "sceneChange",
      sceneChange("rgl_out", delete = rgl_react$data_pts, add = new_pts)
    )
    rgl_react$data_pts <- new_pts
  })
  
  observeEvent(input$build_mapper, {
    req(input$build_mapper)
    # f_x <- tourr::rescale(cpath()$interpolate(input$alpha_index))
    # current_mapper <<- chem_mapper(f_x)
    # output$grapher <- grapher::renderGrapher({ current_mapper$as_grapher() })
  })
})

shiny::shinyApp(ui, server)
```



```{r}
break_pts <- sapply(m$cover$level_sets, function(idx){
  hcl <- hclust(dist(m$X[idx,]), method = "single")
  breaks <- as.double(seq(head(hcl$height,1L), tail(hcl$height,1L), length.out = num_bins))
  bin_idx <- tabulate(findInterval(x = as.double(hcl$height), vec = breaks, rightmost.closed = FALSE, all.inside = TRUE, left.open = FALSE), nbins = num_bins)
  cut_idx <- Mapper:::findFirstEqual(bin_idx, 0L) ## only need the first position
  breaks[cut_idx]
})
global_thresh <- median(break_pts)

cl <- sapply(m$cover$level_sets, function(idx){
  hcl <- hclust(dist(m$X[idx,]), method = "single")
  cutree(hcl, h = global_thresh)
})

x <- m$X[m$cover$level_sets$`(3)`,]
hcl <- hclust(dist(x), method = "single")
# min_h <- min(hcl$height[hcl$height > sqrt(.Machine$double.eps)])
breaks <- as.double(seq(head(hcl$height,1L), tail(hcl$height,1L), length.out = num_bins))
bin_idx <- tabulate(findInterval(x = as.double(hcl$height), vec = breaks, rightmost.closed = FALSE, all.inside = TRUE, left.open = FALSE), nbins = num_bins)


```



```{r}

data("noisy_circle", package = "Mapper")
X <- as.data.frame(noisy_circle)
colnames(X) <- c("x", "y")

## Filter 
f_x <- 
  
## Main plot 
plot(noisy_circle, pch = 20, asp = 1, xlab = "X", ylab = "Y", main = "Circle")
ggplot2::ggp

## Filter plot
left_pt <- noisy_circle[which.min(noisy_circle[, 1]),]
f_x <- matrix(apply(noisy_circle, 1, function(pt) (pt - left_pt)[1]))


## Mapper 
m <- mapper(X = noisy_circle, filter_values = f_x, 
            cover_params = list(typename="restrained rectangular", 
                                number_intervals=10L, percent_overlap=50),
            measure = "euclidean", 
            cluster_params = list(cl="single", num_bins=10L))


## 
```

```{r}
library("ggvis")
f_x <- as.data.frame(f_x)
f_x <- cbind(f_x, runif(nrow(f_x)))
colnames(f_x) <- c("f(X)", "Jitter")
ggvis::ggvis(f_x) %>% 
  ggvis::layer_points(x=~`f(X)`, y=~Jitter) %>% 
  ggvis::scale_numeric("")
```




```{r}
library("ggvis")
p <- ggvis(mtcars, x = ~wt, y = ~mpg)
layer_points(p)


slider <- input_slider(10, 1000)
data_x <- expand.grid(x=seq(10),y=seq(10))
data_x %>% ggvis(x=~x, y=~y) %>%
  layer_points(fill:="red") %>%
  layer_points(stroke := "black", fill := NA, size := slider)


# x <- reactive({
#   data.frame(x1=rnorm(10), x2=rnorm(10))
# })
x <- data.frame(x1=rnorm(10), x2=rnorm(10))
  # r_t <- matrix(c(cos(90), sin(90), -sin(90), cos(90)), nrow = 2)
  # r_target <- as.matrix(x) %*% r
rotate <- function(X, e){
  if (e == 0){ return(X) }
  if (e >= 1 && e <= 90){
    theta <- e*pi/180
    r <- matrix(c(cos(theta), sin(theta), -sin(theta), cos(theta)), nrow = 2)
    return(t(r %*% t(as.matrix(X))))
  } 
  return(NULL)
}
# class(rotate) <- append(class(rotate), "tour_path")
aps <- 2
fps <- 30
make_counter <- function(start, end, reset=TRUE){
  cc <<- start
  return(function(){
    if (cc >= end){ if(reset) cc <<- start else return(NULL) }
    else { cc <<- cc+1L; return(cc-1L) }
  })
}
counter <- make_counter(0, 90)
proj_data <- reactive({
  invalidateLater(1000 / fps, NULL)
  step <- counter()
  print(step)
  if (!is.null(step)){ return(structure(data.frame(rotate(x, step)), names = c("x1", "x2"))) }
  else { return(NULL) }
})
proj_data %>% 
  ggvis(~x1, ~x2) %>% layer_points() %>% 
  scale_numeric("x", domain = c(-3, 3)) %>%
  scale_numeric("y", domain = c(-3, 3)) %>%
  add_axis("x", title = "") %>% add_axis("y", title = "") %>%
  set_options(duration = 0)

x <- replicate(2, rnorm(100))
cmdscale(dist(x), k = 2)

theta_slider <- input_slider(min = 0, max = 90, value = 0, animate = TRUE)

library(shiny)
library(ggvis)
library(tourr)
gtour <- function(data, groups) {
  aps <- 2 # angular velocity
  fps <- 30
  mat <- rescale(as.matrix(data))
  tour <- new_tour(mat, little_tour(), NULL)
  start <- tour(0)
  proj_data <- reactive({
    invalidateLater(1000 / fps, NULL);
    step <- tour(aps / fps)
    data.frame(center(mat %*% step$proj), groups = groups)
  })
  proj_data %>% ggvis(~X1, ~X2, fill = ~groups) %>%
    layer_points() %>%
    scale_numeric("x", domain = c(-1, 1)) %>%
    scale_numeric("y", domain = c(-1, 1)) %>%
    add_axis("x", title = "") %>% add_axis("y", title = "") %>%
    set_options(duration = 0)
}

ggvis::layer_lines()




  ggvis::axis_props()
    lines(adj(cos(theta)), adj(sin(theta)), col = "grey50")
    text(adj(proj[, 1]), adj(proj[, 2]), label = labels, col = "grey50")

apply(, 2, function(xy){ as.list(xy) })
mapply(function(x, y, z, w){
  matrix(c(x, z, y, w), nrow = 2, byrow = FALSE)
}, x0, x1, y0, y1)

    segments(rep(0, 5), rep(0, 5), res$proj[,1], res$proj[,2], col = "grey50")
    theta <- seq(0, 2 * pi, length = 50)
    lines(adj(cos(theta)), adj(sin(theta)), col = "grey50")
    text(res$proj[,1], res$proj[,2], label = abbreviate(colnames(chemdiab[, 1:5])), col = "grey50")

x2 <- rotate(90)$proj
```

```{r}
library("tourr")
data("banknote", package = "mclust")

bn <- rescale(as.matrix(banknote[, 2:7]))

  
adj <- local({
  limits <- 1
  axis_scale <- limits/6
  axis_pos <- 0.8
  function(x) axis_pos + x * axis_scale
})


## Base R graphics to show the PP unit-vector projection axes 
res <- tour(100)
plot.new()
plot.window(xlim=c(-1, 1), ylim=c(-1,1), mar=rep(0, 4))
segments(rep(0, 5), rep(0, 5), res$proj[,1], res$proj[,2], col = "grey50")
theta <- seq(0, 2 * pi, length = 50)
lines(cos(theta), sin(theta), col = "grey50")
labels <- abbreviate(colnames(bn), 3)
text(res$proj[, 1], res$proj[, 2], label = labels, col = "grey50", pos = 3)



ggvis::ggvis(data = pp_arrows) %>% 
  layer_paths(~x, ~y) %>% 
  group_by(group) %>% 
  scale_numeric("x", domain = c(-1, 1)) %>%
  scale_numeric("y", domain = c(-1, 1)) %>% 
  layer_paths(data=circle, x=~x, y=~y) %>% 
  layer_text(data=label_xy, text := ~label, x=~x, y=~y)

## This is probably not efficient
# wut <- save_history(bn, little_tour())

output$ex2 <- renderUI({
    withMathJax(
      helpText('and output 2 $$3^2+4^2=5^2$$')
    )
})


library(ggvis)

## Shiny app to enable interactive PP
ui <- fluidPage(
  title = titlePanel("Projection Pursuit"),
  withMathJax(),
  sidebarLayout(
    sidebarPanel = sidebarPanel(
      selectInput("tour_plan", label = "Tour Path", choices = c("Little")),
      sliderInput("step_size", label = "Step size", min = 1, max = 10, step = 1, value = 1),
      actionButton("make_step", label = "Pursue step"),
      actionButton("start_pursuit", label = "Pursue continuous"),
      uiOutput("tour_input_ui")
    ), mainPanel = mainPanel(
      fluidRow( ggvisOutput("ggvis_proj_xy") ),
      fluidRow( ggvisOutput("ggvis_proj_dir") )
    )
  )
)

# udv <- svd(bn)
# ?GPArotation::Varimax

# tourr::guided_tour(index_f = lda_pp(as.character(banknote$Status)))()

x_cn <- colnames(bn)

server <- function(input, output, session){
  
  ## Set the current tour path
  c_tour <- new_tour(bn, little_tour(), NULL)
  
  ## Projected data 
  rv <- reactiveValues()
  rv$delay <- Inf
  rv$cum_step <- 0 # Trick to invalidate the reactive below
  rv$c_proj <- reactive({ 
    invalidateLater(rv$delay)
    rv$cum_step
    c_tour(1) 
  }) #input$step_sizes
  
  ## Outer circle (static)
  theta <- seq(0, 2 * pi, length = 150)
  circle <- data.frame(x=cos(theta), y=sin(theta))
  
  ## PP arrows DF
  pp_arrows <- reactive({
    res <- rv$c_proj()
    x_coords <- as.vector(rbind(x0=0, x1=res$proj[,1]))
    y_coords <- as.vector(rbind(y0=0, y1=res$proj[,2]))
    dim <- rep(colnames(bn), each=2)
    data.frame(x=x_coords, y=y_coords, group=dim)
  })
  
  ## Labels 
  label_xy <- reactive({
    res <- rv$c_proj()
    data.frame(label=as.character(colnames(bn)), x=res$proj[,1], y=res$proj[,2])
  })
  
  ## Make ggvis PP circle
  ggvis(data = pp_arrows) %>%
    layer_paths(~x, ~y) %>% 
    group_by(group) %>% 
    scale_numeric("x", domain = c(-1, 1)) %>%
    scale_numeric("y", domain = c(-1, 1)) %>% 
    layer_paths(data=circle, x=~x, y=~y) %>% 
    layer_text(data=label_xy, text := ~label, x=~x, y=~y) %>% 
    bind_shiny(plot_id = "ggvis_proj_dir")
  
  ## Show projected data
  proj_xy <- reactive({
    res <- rv$c_proj()
    structure(data.frame(center(bn %*% res$proj), banknote$Status), names = c("X1", "X2", "label"))
  })
  
  ## Bind the ggvis to the shiny plot output 
  proj_xy %>% ggvis(~X1, ~X2) %>%
    layer_points(fill = ~factor(label)) %>%
    scale_numeric("x", domain = c(-1, 1)) %>%
    scale_numeric("y", domain = c(-1, 1)) %>%
    add_axis("x", title = "") %>% add_axis("y", title = "") %>% 
    bind_shiny(plot_id = "ggvis_proj_xy")
  
  ## Controls pursuit of the target projection
  observeEvent(input$make_step, {
     rv$cum_step <- rv$cum_step + 1L 
  })
  
  ## Continuous path interpolation until the button is clicked again 
  observeEvent(input$start_pursuit, {
    rv$delay <- 100
  })
  
  observeEvent(input$tour_plan, {
    req(input$tour_plan)
    tp <- toupper(input$tour_plan)
    if (tp == "LITTLE"){
      output$tour_input_ui <- renderUI({
        idx <- apply(res$target, 2, which.max)
        htmltools::tagList(
          htmltools::p("Target projection axes:"),
          htmltools::span(sprintf("x-axis: %s", x_cn[idx[1]])),
          htmltools::span(sprintf("y-axis: %s", x_cn[idx[2]]))
        )
      })
    }

  })
}

shinyApp(ui=ui,server=server)


ggvis::layer_lines()

tour(2)
```


```{r}
## Load chemical diabetes data set
library(locfit)
data("chemdiab", package = "locfit")

## L-Infinity eccentricity 
X <- tourr::rescale(as.matrix(chemdiab[, -6]))
f_ecc <- matrix(apply(as.matrix(dist(X)), 1, max))

## Make the mapper 
chem_mapper <- function(f_x){
  stopifnot(is.matrix(f_x))
  H <- apply(X, 2, stats::bw.nrd0)
  kde_res <- ks::kde(x = f_x, H = diag(H, nrow = ncol(f_x), ncol = ncol(f_x)), eval.points = f_x, binned = FALSE)
  m <- Mapper::MapperRef$new(X = X)
  m$use_cover(matrix(kde_res$estimate), typename = "fixed rectangular", number_intervals = 8L, percent_overlap = 35)
  m$use_clustering_algorithm(cl = "single", num_bins = 10L)
  m$use_distance_measure(measure = "euclidean")
  m$compute_k_skeleton(k = 1L)
  return(m)
}

loadings <- reshape2::melt(unclass(loadings(pca_chemdiab)))
colnames(loadings) <- c("Dim", "Factor", "Load")
# GPArotation
loadings %>% 
  ggvis(~Dim, ~Factor, fill = ~Load) %>% 
  layer_rects(width = band(), height = band()) %>% 
  scale_nominal("x", padding = 0, points = FALSE) %>%
  scale_nominal("y", padding = 0, points = FALSE)

vc <- colnames(chemdiab[, -6])
ui <- shinyUI(pageWithSidebar(
  headerPanel = headerPanel("\"Visualization is insight; not pictures\""),
  sidebarPanel = sidebarPanel(
    sliderInput("alpha_index", label = "Alpha", min = 0, max = 1, value = 0, step = 1/25, 
                animate = animationOptions(interval=40*2, loop=FALSE)), 
    selectInput("dim1_1", label = "Dim. 1", choices = vc, selected = vc[[1]], width = "30%"), 
    selectInput("dim1_2", label = "Dim. 2", choices = vc, selected = vc[[2]], width = "30%"),
    selectInput("source_dim", label = "Source dim.", choices = vc, selected = vc[[1]], width = "30%"),
    selectInput("target_dim", label = "Target dim.", choices = vc, selected = vc[[3]], width = "30%"),
    actionButton("build_mapper", label = "Build Mapper")
  ), 
  mainPanel = mainPanel(
    rgl::rglwidgetOutput("rgl_out", width = "100%", height = "50%"),
    grapher::grapherOutput("grapher", width = "100%", height = "50%"),
    style = "height: 100vh !important;"
  )
))

server <- shinyServer(function(input, output, session) {
  ## Initialize the scene
  plot3d(rgl_scene)
  
  ## Set callback to appropriately cleanup the RGL session on exit
  dev <- rgl.cur(); save <- options(rgl.inShiny = TRUE)
  on.exit(options(save))
  session$onSessionEnded(function() { rgl.set(dev); rgl.close() })
  
  ## Reactives
  from_dims <- reactive({ c(input$dim1_1, input$dim1_2, input$dim1_3) })
  to_dims <- reactive({ c(input$dim2_1, input$dim2_2, input$dim2_3) })
  cpath <- reactive({
    req(from_dims())
    req(from_dims())
    tourr::geodesic_path(as.matrix(X[, from_dims()]), as.matrix(X[, to_dims()]))
  })
  
  ## Reactive values to stroe the current points
  rgl_react <- reactiveValues()
  rgl_react$data_pts <- NULL # rgl::points3d(tourr::rescale(path$interpolate(0)))
  output$rgl_out <- rgl::renderRglwidget({ 
    rgl_widget <<- rgl::rglwidget()
    return(rgl_widget)
  })
  rgl::plot3d(NULL, xlim = c(0,1), ylim=c(0, 1), zlim=c(0, 1))
  
  ## Render mapper
  output$grapher <- grapher::renderGrapher({
    current_mapper$as_grapher()
  })
  
  ## Observer to modify the projection along a geodesic
  observeEvent(input$alpha_index, {
    # req(input$alpha_index)
    if (!is.null(rgl_react$data_pts)){ rgl::delFromSubscene3d(rgl_react$data_pts) }
    new_pts <- rgl::points3d(tourr::rescale(cpath()$interpolate(input$alpha_index)), color = palette()[chemdiab$cc])
    session$sendCustomMessage(
      "sceneChange",
      sceneChange("rgl_out", delete = rgl_react$data_pts, add = new_pts)
    )
    rgl_react$data_pts <- new_pts
  })
  
  observeEvent(input$build_mapper, {
    req(input$build_mapper)
    # f_x <- tourr::rescale(cpath()$interpolate(input$alpha_index))
    # current_mapper <<- chem_mapper(f_x)
    # output$grapher <- grapher::renderGrapher({ current_mapper$as_grapher() })
  })
})

shiny::shinyApp(ui, server)
```



```{r}
break_pts <- sapply(m$cover$level_sets, function(idx){
  hcl <- hclust(dist(m$X[idx,]), method = "single")
  breaks <- as.double(seq(head(hcl$height,1L), tail(hcl$height,1L), length.out = num_bins))
  bin_idx <- tabulate(findInterval(x = as.double(hcl$height), vec = breaks, rightmost.closed = FALSE, all.inside = TRUE, left.open = FALSE), nbins = num_bins)
  cut_idx <- Mapper:::findFirstEqual(bin_idx, 0L) ## only need the first position
  breaks[cut_idx]
})
global_thresh <- median(break_pts)

cl <- sapply(m$cover$level_sets, function(idx){
  hcl <- hclust(dist(m$X[idx,]), method = "single")
  cutree(hcl, h = global_thresh)
})

x <- m$X[m$cover$level_sets$`(3)`,]
hcl <- hclust(dist(x), method = "single")
# min_h <- min(hcl$height[hcl$height > sqrt(.Machine$double.eps)])
breaks <- as.double(seq(head(hcl$height,1L), tail(hcl$height,1L), length.out = num_bins))
bin_idx <- tabulate(findInterval(x = as.double(hcl$height), vec = breaks, rightmost.closed = FALSE, all.inside = TRUE, left.open = FALSE), nbins = num_bins)


```


