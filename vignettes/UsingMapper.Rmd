---
title: "Using the Mapper package"
author: "Matt Piekenbrock"
output: html_notebook
---

Consider a noisy sampling along the perimeter of a circle 
```{r}
## Generate noisy points around the perimeter of a circle 
n <- 150
t <- 2*pi*runif(n)
r <- runif(n, min = 2, max = 2.1)
circ <- cbind(r*cos(t), r*sin(t))

## Define filter values equal to the distance from each point to the left-most point in the circle 
left_pt <- circ[which.min(circ[, 1]),]
f_x <- sqrt(colSums(apply(circ, 1, function(pt) (pt - left_pt)^2)))

## Bin the data onto a sufficiently high-resolution rainbow gradient from blue (low) to red (high), 
## and plot the original circle  with these values
rbw_pal <- rev(rainbow(100, start = 0, end = 4/6))
binned_idx <- cut(f_x, breaks = 100, labels = F)
plot(circ, pch = 20, asp = 1, col = rbw_pal[binned_idx], xlab = "X", ylab = "Y", main = "Circle")
```

To get the mapper of this circle, first supply the data via the `X` parameter and the filtered values via the 
`filter_values` argument, e.g. `mapper(X = circ, filter_values = f_x, ...)`. `Mapper` dispatches additional parameters passed in `...` to other methods to further configure the construction. See `?mapper` for more details. To use a primitive multidimensional, 'hyper-rectangular' cover, supply the `number_intervals` and `overlap` parameters. A summary is available with the default print method. 
```{r}
m <- Mapper::mapper(X = circ, filter_values = f_x, number_intervals = 5, overlap = 0.20)
m
```
By default, the core information of the $1$-skeleton of the `Mapper` construction is returned, including:
  1. The nodes of the topological graph, and the indices of the points contained within each node.
  2. The adjacency matrix of the topological graph. 
  3. The level sets indexing information, and the indices of the nodes they contain in each level set.
This is, generally, all one needs to analyze the Mapper construction. 

Internally, Mapper uses `ReferenceClasses` to efficiently compute the simplicial complex. If more information is required beyond the static construction, the `return_reference` parameter may be set to `TRUE` to access the underlying `MapperRef` object. This is useful in situations where each step of the mapper framework needs fine-tuned, e.g. where the construction is requested under multiple parameter settings.  

```{r}
m_ref <- Mapper::mapper(X = circ, filter_values = f_x, number_intervals = 5, overlap = 0.20, return_reference = TRUE)
m_ref
```
There are many internal methods which may be called at any time to reconfigure the Mapper object.
```{r}
ls(m_ref)
ls(m_ref$cover)
```

Keep in mind that to keep the reference object around, copies of the original data and filter values are stored internally. Thus, the reference object takes up significantly more memory than the bare components.
```{r}
suppressMessages(library("pryr", quietly = TRUE))
pryr::object_size(m)
pryr::object_size(m_ref)
```

If the dimensionality is low enough, there's default methods to plot the network or look at the filter space: 
```{r}
m_ref$plotNetwork()
m_ref$cover$plotFilterSpace()
```

The Mapper packages provides a [force-directed](https://github.com/d3/d3-force) [htmlwidget](https://www.htmlwidgets.org/) implementation of Ayasdi's open source [grapher](https://github.com/ayasdi/grapher) library, which can be used to visualize the Mapper network. 
```{r}
g <- Mapper::grapher(m_ref)
g$widget %>% 
  g$center() ## if this doesn't show up in the RStudio viewer, change the viewer options to see it in the browser with options(viewer=NULL)
```

A simple interface class `grapher` is provided to programmatically interact with the widget. The methods can be printed as follows: 
```{r}
print(ls(g))
```

The grapher instance is fully shiny-compatible. For larger datasets An interactive dashbaord is included to help analyze the Mapper. 
```{r}
## Load FICO heloc data set
fico <- data.table::data.table(readr::read_csv("~/WaCS/TDA/heloc_dataset_v1.csv"))
normalize <- function(x){ (x - min(x))/(max(x) - min(x)) }
fico_x <- fico[, -1, with = FALSE]
fico_x <- apply(as.matrix(fico_x), 2, normalize)

## Do very basic LDA on Risk Performance
fico_lda <- MASS::lda(x = fico_x, grouping = fico$RiskPerformance, prior = c(0.50, 0.50)) # everybody deserves an equal chance
f_x <- as.matrix(fico_x) %*% fico_lda$scaling ## Binary classification == 1D subspace 
fico_m <- Mapper::mapper(fico_x, filter_values = f_x, number_intervals = 50L, overlap = 1/3, return_reference = TRUE)
Mapper::dashboard(fico_m, X = fico, node_color_f = "default")
```


