---
title: "Using the Mapper package"
author: "Matt Piekenbrock"
output:
  html_document:
    df_print: paged
  html_notebook: default
  pdf_document: default
---

Consider a noisy sampling along the perimeter of a circle 
```{r}
## Generate noisy points around the perimeter of a circle 
n <- 1500
t <- 2*pi*runif(n)
r <- runif(n, min = 2, max = 2.1)
noisy_circle <- cbind(r*cos(t), r*sin(t))

## Define filter values equal to the distance from each point to the left-most point in the circle 
left_pt <- noisy_circle[which.min(noisy_circle[, 1]),]
f_x <- apply(noisy_circle, 1, function(pt) (pt - left_pt)[1])

## Bin the data onto a sufficiently high-resolution rainbow gradient from blue (low) to red (high), 
## and plot the original circle  with these values
rbw_pal <- rev(rainbow(100, start = 0, end = 4/6))
binned_idx <- cut(f_x, breaks = 100, labels = F)
plot(noisy_circle, pch = 20, asp = 1, col = rbw_pal[binned_idx], xlab = "X", ylab = "Y", main = "Circle")
```

To get the mapper of this circle, first supply the data via the `X` parameter and the filtered values via the 
`filter_values` argument, e.g. `mapper(X = circ, filter_values = f_x, ...)`. `Mapper` dispatches additional parameters passed in `...` to other methods to further configure the construction. See `?mapper` for more details. To use a primitive multidimensional, 'hyper-rectangular' cover, supply the `number_intervals` and `overlap` parameters. A summary is available with the default print method. 
```{r}
m <- Mapper::mapper(X = circ, filter_values = f_x, number_intervals = 5, overlap = 0.20)
m
```
By default, the core information of the $1$-skeleton of the `Mapper` construction is returned, including:
  1. The vertices of the topological graph, and the indices of the points contained within each vertex
  2. The adjacency matrix of the topological graph. 
  3. The index set of the cover, and the indices of the vertices they contain in each level set.
This is, in the simplest case, all of the central information one needs prior to doing a more in-depth analysis. 

## Interactively building the Mapper

For most use-cases, the static method above is sufficient for getting a compact Mapper construction back. However, building the 'right' Mapper may be an interactive process, requiring parameter tuning, exploring alternative filter functions, tweaking clustering algorithms, etc. For large data sets, this iterative fitting process can be prohibitively expensive. 

Internally, Mapper uses `R6` classes to efficiently compute the simplicial complex. One of the nice benefits of R6 is that it allows method chaining. 
To demonstrate this, consider the usual Mapper pipeline: 
  1. Specify a filter function for the data 
  2. Equip the filter space with a cover
  3. Construct the _k_-skeleton
<!-- If more information is required beyond the static construction, the `return_reference` parameter may be set to `TRUE` to access the underlying `MapperRef` object. This is useful in situations where each step of the mapper framework needs fine-tuned, e.g. where the construction is requested under multiple parameter settings.   -->

These steps are demonstrated below using the `noisy_circle` data set above with the `Mapper` package.

The first step is to create a _filter_ of the data. Naturally, this step 

```{r}
## 1. Specify a filter function for the data 
left_pt <- noisy_circle[which.min(noisy_circle[, 1]),]
f_x <- sqrt(colSums(apply(noisy_circle, 1, function(pt) (pt - left_pt)^2)))
```

The second step is to create a cover over the space. 
```{r}
## 2. Create cover of the filter space
rec_cover <- Mapper::FixedRectangularCover$new(filter_values = f_x)
```
The only required argument is the filter point values themselves; cover-specific parameters may optionally be supplied at initialization, or set via assignment. 
```{r}
rec_cover$number_intervals <- 5L
rec_cover$percent_overlap <- 0.20
```
```{r}
## Equivalent to 
# FixedRectangularCover$new(filter_values = f_x, number_intervals = 5L, percent_overlap = 0.20)
```
```{r}
print(rec_cover)
```
Once parameterized, the cover can be explicitly constructed via the `construct_cover` member function. The `construct_cover` function uses the given set of parameters to populates the level sets of the cover, a list of integer indices indicating which filter points intersects a given level set. 
If not explicity called, the cover will be constructed when the Mapper reference is made.  

```{r}
## 3.  Apply a partial clustering to the data subsets indexed by the cover 
m <- Mapper::MapperRef$new(noisy_circle)
m$cover <- rec_cover

## Equivalent to Mapper::MapperRef$new(noisy_circle, cover = rec_cover)
```

The final step to create a Mapper is to construct the _k_-skeleton. This step requires a different set of procedures, based on _k_. 

Since the definition of a _k_-skeleton is inductive, the first step is to construct the $0$-skeleton. This amounts to applying a partial clustering over [subsets of] the data within a give metric space, indexed by the level sets given by cover. The choice of clustering algorithm, metric, hyper-parameters, etc. is completely up to the user--the only requirement is that the function take as input at least the data `X` and a vector of indices `idx`$\subset \{1, 2, \dots, n\}$ and return an integer vector giving a partitioning on the subset `idx` of the data `X`. An example of supplying a custom clustering function using the `parallelDist` and `fastcluster` packages is given below: 

```{r}
{ require("parallelDist"); require("fastcluster") }
custom_clustering_f <- function(X, idx, num_bins){
  dist_x <- parallelDist::parallelDist(X[idx,], method = "euclidean")
  hcl <- fastcluster::hclust(dist_x, method = "single")
  cutoff_first_bin(hcl, num_bins = num_bins)
}
m$clustering_algorithm <- custom_clustering_f
```

To simplify these choices, the user may alternatively simply choose from the list of widely-supported hierarchical clustering algorithms (i.e. linkage criteria) and distance measures with the `set_clustering_algorithm` and `set_distance_measure` functions, respectively. 
```{r}
m$set_clustering_algorithm(cl = "single")
m$set_distance_measure(measure = "euclidean")
```
For a complete list of the available linkage criteria and distance/similarity measures, see `?stats::hclust` and `?proxy::pr_DB`, respectively.

Once these have been set, the $0$-skeleton is computed with the `compute_vertices` function. All parameters passed to `compute_vertices` are passed via `...` as hyper-parameters to the clustering algorithm. 
```{r}
m$compute_vertices(num_bins = 10L)
```

The parameters of these functions may be fine-tuned to allow adjusting only specific parts of the skeleton at a time. 

The $1$-skeleton is computed analogously.
```{r}
m$compute_edges()
```

Generally, this is sufficient. However, if the user wishes too, the $k$-skeleton for any $k > 1$ can also be computed. 
```{r}
m$compute_k_skeleton(k = 1L)
```

All the methods can chained. 
```{r}
m <- MapperRef$new(noisy_circle)$
  use_cover(filter_values = f_x, type = "fixed rectangular", number_intervals = 5L, percent_overlap = 0.35)$
  use_clustering_algorithm(cl = "single")$
  use_distance_measure(measure = "euclidean")$
  compute_vertices(num_bins = 10)$
  compute_edges()
```

To plot an interactive, force-directed version of the topological graph, just call `$plot_interactive` function.
```{r}
m$plot_interactive()
```

This returns 

With R6, this provides a nice way to interactively build the construction. It also, however can be useful. 

Keep in mind that to keep the reference object around, copies of the original data and filter values are stored internally. Thus, the reference object takes up significantly more memory than the bare components.
```{r}
suppressMessages(library("pryr", quietly = TRUE))
pryr::object_size(m)
pryr::object_size(m_ref)
```

If the dimensionality is low enough, there's default methods to plot the network or look at the filter space: 
```{r}
m_ref$plotNetwork()
m_ref$cover$plotFilterSpace()
```

The Mapper packages provides a [force-directed](https://github.com/d3/d3-force) [htmlwidget](https://www.htmlwidgets.org/) implementation of Ayasdi's open source [grapher](https://github.com/ayasdi/grapher) library, which can be used to visualize the Mapper network. 
```{r}
library("grapher")
g <- grapher::grapher(m_ref)
g
```

A simple interface class `grapher` is provided to programmatically interact with the widget. The methods can be printed as follows: 
```{r}
library(printr)
help(package = "grapher")
```

The grapher instance is fully shiny-compatible. For larger datasets An interactive dashbaord is included to help analyze the Mapper. 
```{r, eval = FALSE}
# ## Load FICO heloc data set
# fico <- data.table::data.table(readr::read_csv("~/WaCS/TDA/heloc_dataset_v1.csv"))
# normalize <- function(x){ (x - min(x))/(max(x) - min(x)) }
# fico_x <- fico[, -1, with = FALSE]
# fico_x <- apply(as.matrix(fico_x), 2, normalize)
# 
# ## Do very basic LDA on Risk Performance
# fico_lda <- MASS::lda(x = fico_x, grouping = fico$RiskPerformance, prior = c(0.50, 0.50)) # everybody deserves an equal chance
# f_x <- as.matrix(fico_x) %*% fico_lda$scaling ## Binary classification == 1D subspace 
# fico_m <- Mapper::mapper(fico_x, filter_values = f_x, number_intervals = 50L, overlap = 1/3, return_reference = TRUE)
# Mapper::dashboard(fico_m, X = fico, node_color_f = "default")
```
