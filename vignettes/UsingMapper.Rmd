---
title: "Using the Mapper package"
author: "Matt Piekenbrock"
output:
  html_notebook: default
  html_document:
    df_print: paged
  pdf_document: default
---

Consider a noisy sampling of points along the perimeter of a circle in $\mathbb{R}^2$
```{r}
## Generate noisy points around the perimeter of a circle 
n <- 1500
t <- 2*pi*runif(n)
r <- runif(n, min = 2, max = 2.1)
noisy_circle <- cbind(r*cos(t), r*sin(t))

## Define filter values equal to the distance from each point to the left-most point in the circle 
left_pt <- noisy_circle[which.min(noisy_circle[, 1]),]
f_x <- matrix(apply(noisy_circle, 1, function(pt) (pt - left_pt)[1]))

## Bin the data onto a sufficiently high-resolution rainbow gradient from blue (low) to red (high), 
## and plot the original circle  with these values
rbw_pal <- rev(rainbow(100, start = 0, end = 4/6))
binned_idx <- cut(f_x, breaks = 100, labels = F)
plot(noisy_circle, pch = 20, asp = 1, col = rbw_pal[binned_idx], xlab = "X", ylab = "Y", main = "Circle")
```

To get the mapper of this circle, first supply the data via the `X` parameter and the filtered values via the 
`filter_values` argument, e.g. `mapper(X = circ, filter_values = f_x, ...)`. `Mapper` dispatches additional parameters passed in `...` to other methods to further configure the construction. See `?mapper` for more details. To use a primitive multidimensional, 'hyper-rectangular' cover, supply the `number_intervals` and `overlap` parameters. A summary is available with the default print method. 
```{r}
m <- Mapper::mapper(X = noisy_circle, filter_values = f_x, number_intervals = 5, overlap = 0.20)
m
```
By default, the core information of the $1$-skeleton of the `Mapper` construction is returned, including:
  1. The vertices of the topological graph, and the indices of the points contained within each vertex
  2. The adjacency matrix of the topological graph. 
  3. The index set of the cover, and the indices of the vertices they contain in each level set.
This is, in the simplest case, all of the central information one needs prior to doing a more in-depth analysis. 

## Interactively building the Mapper

For most use-cases, the static method above is sufficient for getting a compact Mapper construction back. However, building the 'right' Mapper may be an interactive process, requiring parameter tuning, exploring alternative filter functions, tweaking clustering algorithms, etc. For large data sets, this iterative fitting process can be prohibitively expensive. 

Internally, Mapper uses `R6` classes to efficiently compute the simplicial complex. One of the nice benefits of R6 is that it allows [method chaining](https://adv-r.hadley.nz/R6.html#method-chaining). 
To demonstrate this, consider a very simplified interpretation of the Mapper pipeline: 
  1. "Filter" the data via a reference map
  2. Equip the filter space with a cover
  3. Construct the _k_-skeleton
<!-- If more information is required beyond the static construction, the `return_reference` parameter may be set to `TRUE` to access the underlying `MapperRef` object. This is useful in situations where each step of the mapper framework needs fine-tuned, e.g. where the construction is requested under multiple parameter settings.   -->

These steps are demonstrated below using the `noisy_circle` data set above with the `Mapper` package.

The first step is to create a _filter_ of the data. 

```{r}
## 1. Specify a filter function for the data 
left_pt <- noisy_circle[which.min(noisy_circle[, 1]),]
f_x <- sqrt(colSums(apply(noisy_circle, 1, function(pt) (pt - left_pt)^2)))
```

The second step is to create a cover over the space. 
```{r}
## 2. Create cover of the filter space
rec_cover <- Mapper::FixedRectangularCover$new(filter_values = f_x)
```
The only required argument is the filter point values themselves; cover-specific parameters may optionally be supplied at initialization, or set via assignment. 
```{r}
rec_cover$number_intervals <- 5L
rec_cover$percent_overlap <- 0.20
```
If you supply a single value when the filter dimensionality $> 1$, the argument is recycled. The cover summary can be printed as follows: 

```{r}
print(rec_cover)
```

Once parameterized, the cover must be explicitly constructed via the `construct_cover` member function before using. The `construct_cover` function uses the given set of parameters to populates the level sets of the cover, a list of integer indices indicating which filter points intersect a given level set. If not explicity called, the cover will be constructed when the Mapper reference is made.  

```{r}
## 3.  Apply a partial clustering to the data subsets indexed by the cover 
m <- Mapper::MapperRef$new(noisy_circle)
m$cover <- rec_cover
```

The final step to create a Mapper is to construct the _k_-skeleton. This step requires a different set of procedures, based on _k_.

### Building the 0-skeleton 

Since the definition of a _k_-skeleton is inductive, the first step is to construct the $0$-skeleton. This amounts to applying a partial clustering over [subsets of] the data within a given metric space, indexed by the level sets given by cover. The choice of clustering algorithm, metric, hyper-parameters, etc. is completely up to the user--the only requirement is that the function take as input at least the data `X` and a vector of indices `idx`$\subset \{1, 2, \dots, n\}$ and return an integer vector giving a partitioning on the subset `idx` of the data `X`. An example of using a custom clustering function using the `parallelDist` and `fastcluster` packages is given below, wherein the [single linkage criterion] is used to build a cluster hierarchy, and then a histogram-based heuristic is used to set the [cut value](?stats::cutree). The heuristic is similar to the idea discussed in Section 3.1 of the original Mapper paper. 

```{r}
{ require("parallelDist"); require("fastcluster") }
custom_clustering_f <- function(X, idx, num_bins){
  dist_x <- parallelDist::parallelDist(X[idx,], method = "euclidean")
  hcl <- fastcluster::hclust(dist_x, method = "single")
  cutoff_first_bin(hcl, num_bins = num_bins)
}
m$clustering_algorithm <- custom_clustering_f
```

The user may alternatively choose from the list of widely-supported linkage criteria and distance measures used in hierarchical clustering with the `set_clustering_algorithm` and `set_distance_measure` functions, respectively. 
```{r}
m$use_clustering_algorithm(cl = "single")
m$use_distance_measure(measure = "euclidean")
```
For a complete list of the available linkage criteria and distance/similarity measures, see `?stats::hclust` and `?proxy::pr_DB`, respectively.

Once these have been set, the $0$-skeleton is computed with the `compute_vertices` function. All parameters passed to `compute_vertices` are passed via `...` as hyper-parameters to the clustering algorithm. 
```{r}
m$compute_vertices(num_bins = 10L)
```

The parameters of these functions may be fine-tuned to allow adjusting only specific parts of the skeleton at a time. 

### Building the 1-skeleton 

The $1$-skeleton is computed analogously.
```{r}
m$compute_edges()
```

Generally, this is sufficient. However, if the user wishes too, the $k$-skeleton for any $k > 1$ can also be computed. 
```{r}
m$compute_k_skeleton(k = 1L)
```

All the methods can chained. 
```{r}
m <- MapperRef$new(noisy_circle[1:10,])$
  use_cover(filter_values = matrix(f_x[1:10,]), type = "fixed rectangular", number_intervals = 5L, percent_overlap = 0.35)$
  use_clustering_algorithm(cl = "single", num_bins = 10)$
  use_distance_measure(measure = "euclidean")$
  compute_vertices()$
  compute_edges()
```

The output of Mapper is a simplicial complex, or in the simplest case (when $k = 1$), a topological graph. Internally, the complex is stored in a [Simplex Tree](https://hal.inria.fr/hal-00707901v1/document). The underlying simplex tree is exported as an [Rcpp Module](https://cran.r-project.org/web/packages/Rcpp/vignettes/Rcpp-modules.pdf), and is accessible via the `$simplicial_complex` member. 
```{r}
m$simplicial_complex
```
```{r}
m$simplicial_complex$print_tree()
```


### Visualizing the Mapper 

The `grapher` package provides a [force-directed](https://github.com/d3/d3-force) [htmlwidget](https://www.htmlwidgets.org/) implementation of Ayasdi's Apache-licensed [grapher](https://github.com/ayasdi/grapher) library, which can be used to visualize the Mapper network.  
```{r}
library("grapher")
g_am <- m$simplicial_complex$as_adjacency_matrix()
g <- grapher(g_am)
g %>% 
  center()
```

The `$plot_interactive` function provides a few default coloring and sizing options.
```{r}
m$plot_interactive()
```
To customize the visualization, refer to graphers [documentation]().

### Accessing other members  

The full help pages for are accessible via the `?MapperRef` page or the additional reference pages on the documentation website. 

Below is a brief summary: 
```{r}
m$cover$filter_values    ## filter values used to build the cover 
m$cover$index_set        ## index set of the cover 
m$cover$level_sets       ## level set point memberships
m$clustering_algorithm   ## function used to perform the partial clustering 
```


