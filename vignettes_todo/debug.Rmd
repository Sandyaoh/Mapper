---
title: "R Notebook"
output: html_notebook
---
```{r}
library("Mapper")

## Define filter values equal to the distance from each point to the left-most point in the circle 
left_pt <- noisy_circle[which.min(noisy_circle[, 1]),]
f_x <- matrix(apply(noisy_circle, 1, function(pt) (pt - left_pt)[1]))

m <- MapperRef$new(noisy_circle[1:10,])$
  use_cover(filter_values = matrix(f_x[1:10,]), type = "fixed rectangular", number_intervals = 5L, percent_overlap = 0.35)$
  use_clustering_algorithm(cl = "single", num_bins = 10)$
  use_distance_measure(measure = "euclidean")$
  compute_vertices()$
  compute_edges()

```
```{r}
m$enable_multiscale()
m$update_mapper(percent_overlap = 0)
m$update_mapper(percent_overlap = 0.90)
```

```{r}
## Auxillaury variables needed 
percent_overlap <- 0.05

## LS Multi-indices == Cartesian product of the intervals
cart_prod <- arrayInd(seq(prod(m$cover$number_intervals)), .dim = m$cover$number_intervals)

## Get filter min and max ranges
filter_rng <- apply(m$cover$filter_values, 2, range)
{ filter_min <- filter_rng[1,]; filter_max <- filter_rng[2,] }
filter_len <- diff(filter_rng)
    
## Get the bounds associated with the level sets 
base_interval_length <- filter_len/m$cover$number_intervals
interval_length <- base_interval_length + (base_interval_length * percent_overlap)/(1.0 - percent_overlap)
eps <- interval_length/2.0
ls_bnds <- t(apply(cart_prod, 1, function(idx){
  centroid <- filter_min + ((as.integer(idx)-1L)*base_interval_length) + base_interval_length/2.0
  c(centroid - eps, centroid + eps)
}))
```


```{r}
filter_values <- matrix(f_x[1:10,])
multiscale <- m$.__enclos_env__[["private"]][[".multiscale"]]
multiscale$

multiscale$get_nearest_filtration_index(c(0.50))
plot_configuration <- function(d_i, idx){
  if (idx == 0){
    eps <- (base_interval_length/2)
  } else {
    ## Choose the interval (half) width to plot
    eps <- (base_interval_length/2) + dist_to_ls[[d_i]]$target_dist[dist_order[[d_i]]][idx] ## parameterized overlap
  }

  ## Construct the level sets
  ls_endpts <- lapply(1L:filter_dim, function(d_i){
    tmp <- as.vector(sapply(0L:(number_intervals[d_i] - 1L), function(idx){
      centroid <- filter_min[d_i] + (as.integer(idx)*base_interval_length[d_i]) + base_interval_length[d_i]/2.0
      c(centroid - eps[d_i], centroid + eps[d_i])
    }))
    matrix(tmp, ncol = 2, byrow = TRUE)
  })

  plot(filter_values[, d_i], rep(0, 10), pch = 20, ylim = c(-0.75, 0.75), xlab = "", ylab = "", yaxt = "n")
  text(filter_values[, d_i], 0, labels = 1:10, pos = 3)
  abline(h = 0, col = "gray", lty = 3, lwd = 1.5)
  binned_color <- rev(rainbow(nrow(ls_endpts[[d_i]]), start = 0, end = 4/6))
  cc <- 0L
  cls <- ls_endpts[[d_i]]
  for (i in 1:nrow(cls)){
    ls <- cls[i, ]
    if (i %in% c(1, nrow(cls))){
      if (i == 1){
        lines(x = c(ls[1], cls[i+1L, 1L]), y = rep(0.51, 2))
        text(x = mean(c(ls[1], cls[i+1L, 1L])), y = 0.5, pos = 3, labels = as.character(cc))
        cc <- cc + 1
        lines(x = c(cls[i+1L, 1L], ls[2]), y = rep(0.51, 2))
        text(x = mean(c(cls[i+1L, 1L], ls[2])), y = 0.5, pos = 3, labels = as.character(cc))
        cc <- cc + 1
      }
      else if (i == nrow(cls)){
        lines(x = c(cls[i-1L, 2L], ls[2]), y = rep(0.51, 2))
        text(x = mean(c(cls[i-1L, 2L], ls[2])), y = 0.5, pos = 3, labels = as.character(cc))
        cc <- cc + 1
      }
    } else {
      lines(x = c(cls[i-1L, 2L], cls[i+1L, 1L]), y = rep(0.51, 2))
      text(x = mean(c(cls[i-1L, 2L], cls[i+1L, 1L])), y = 0.5, pos = 3, labels = as.character(cc))
      cc <- cc + 1
      lines(x = c(cls[i+1L, 1L], ls[2]), y = rep(0.51, 2))
      text(x = mean(c(cls[i+1L, 1L], ls[2])), y = 0.5, pos = 3, labels = as.character(cc))
      cc <- cc + 1
    }

    lines(x = c(ls[1], ls[2]), y = c(-0.5, -0.5), col = binned_color[i])
    lines(x = c(ls[2], ls[2]), y = c(-0.5, 0.5), col = binned_color[i])
    lines(x = c(ls[2], ls[1]), y = c(0.5, 0.5), col = binned_color[i])
    lines(x = c(ls[1], ls[1]), y = c(0.5, -0.5), col = binned_color[i])
    text(labels = as.character(i - 1L), x = mean(c(ls[1], ls[2])), y = -0.5, col = binned_color[i], pos = 1)
    points(x = mean(c(ls[1], ls[2])), y = 0, pch = 3, col = binned_color[i])
    i <- i + 1
  }
  text(x = cls[nrow(cls), 2L], y = 0.5, pos = 3, labels = as.character(cc))
  points(filter_values[, d_i], rep(0, nrow(filter_values)), pch = 20)
  if (idx > 0){
    points(filter_values[pt_idx[[d_i]][idx], d_i], 0, pch = 21, cex = 1.5, col = "purple")
  }
  text(filter_values[, d_i], 0, labels = 1:nrow(filter_values), pos = 3)
}
```


