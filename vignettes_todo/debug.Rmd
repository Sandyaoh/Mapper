---
title: "R Notebook"
output: html_notebook
---

```{r}
test_cover <- FixedRectangularCover$new(filter_values = cbind(runif(10), runif(10)))
test_cover$percent_overlap <- c(0.25, 0.25)
test_cover$number_intervals <- 3
test_cover$construct_cover()
test_cover$level_sets_to_compare()


```

```{r}
library("Mapper")

## Define filter values equal to the distance from each point to the left-most point in the circle 
left_pt <- noisy_circle[which.min(noisy_circle[, 1]),]
f_x <- matrix(apply(noisy_circle, 1, function(pt) (pt - left_pt)[1]))
f_x <- cbind(f_x, (max(f_x) - f_x^2) + rnorm(length(f_x), sd = 2))

noisy_circle <- cbind(runif(10), runif(10))
f_x <- noisy_circle
  
debug_mapper <- function(){
  m <- MapperRef$new(noisy_circle)$
    use_cover(filter_values = matrix(f_x, ncol = 2), type="fixed rectangular", number_intervals=3L, percent_overlap=0)
  # m$use_clustering_algorithm(cl = "single", num_bins = 10)
  m$clustering_algorithm <- function(X, idx){ rep(1L, length(idx)) }
  m$use_distance_measure(measure = "euclidean")$
    compute_vertices()$
    compute_edges()
}
```

```{Rcpp}
#include <Rcpp.h>
using namespace Rcpp;

// [[Rcpp::export]]
IntegerVector test(IntegerVector x){
  IntegerVector res = self_match(x);
  return(res);
}
```

```{r}
am <- function(m){ m$simplicial_complex$as_adjacency_matrix() }
check_mappers <- function(m1, m2){
  g1 <- igraph::graph_from_adjacency_matrix(am(m1))
  g2 <- igraph::graph_from_adjacency_matrix(am(m2))
  initial_check <- all(c(
    names(m1$ls_vertex_map) == names(m2$ls_vertex_map),
    m1$simplicial_complex$n_simplexes == m2$simplicial_complex$n_simplexes,
    igraph::vcount(g1) == igraph::vcount(g2),
    igraph::ecount(g1) == igraph::ecount(g2),
    sort(igraph::local_scan(g1, k = 1)) == sort(igraph::local_scan(g2, k = 1)),
    sort(igraph::local_scan(g1, k = 2)) == sort(igraph::local_scan(g2, k = 2)),
    sort(igraph::local_scan(g1, k = 3)) == sort(igraph::local_scan(g2, k = 3))
  ))
  
  ## If the initial check passes, do a much more rigorous check: Ensure that every vertex 
  ## has at least one exact correspondence between the two representations
  if (initial_check){
    f_check <- Vectorize(function(i, j){  
      if (length(m1$vertices[[as.character(i)]]) != length(m2$vertices[[as.character(j)]])){ return(FALSE) }
      all(m1$vertices[[as.character(i)]] %in% m2$vertices[[as.character(j)]]) 
    })
    exact_check <- sapply(names(m1$ls_vertex_map), function(ls_key){
      n_vertices <- length(m1$ls_vertex_map[[ls_key]])
      if (n_vertices == 0){ return(n_vertices == length(m2$ls_vertex_map[[ls_key]])) }
      else {
        sum(outer(m1$ls_vertex_map[[ls_key]], m2$ls_vertex_map[[ls_key]], f_check)) >= n_vertices
      }
    })
    return(initial_check && exact_check)
  } else { return(FALSE) }
}
rowmatch <- function(A,B) {
  # Rows in A that match the rows in B
  f <- function(...) paste(..., sep=":")
  if(!is.matrix(B)) B <- matrix(B, 1, length(B))
  a <- do.call("f", as.data.frame(A))
  b <- do.call("f", as.data.frame(B))
  match(a, b)
}
validity_check <- function(m){
  connected_edges <- m$simplicial_complex$as_edge_list()
  all_edges <- apply(t(combn(length(m$vertices), 2)), 2, function(idx) names(m$vertices)[idx])
  conn_idx <- rowmatch(apply(connected_edges, 2, as.character), all_edges)
  
  ## Ensures edges recorded as connected have a non-empty intersection
  connected_check <- all(apply(connected_edges, 1, function(x){
    length(intersect(m$vertices[[as.character(x[1])]], m$vertices[[as.character(x[2])]])) > 0
  }))
  
  ## Ensures edges recorded as unconnected have an empty intersection
  unconnected_check <- all(apply(matrix(all_edges[-conn_idx,], ncol = 2), 1, function(x){
    length(intersect(m$vertices[[as.character(x[1])]], m$vertices[[as.character(x[2])]])) == 0
  }))
  
  ## Return 
  return(connected_check && unconnected_check)
}

## Start with two separate mappers
m1 <- debug_mapper()
m2 <- debug_mapper()

## Base case 
check_mappers(m1, m2)

## Debugging.
{ m1 <- debug_mapper(); m2 <- debug_mapper() }
m1$enable_multiscale() 
multiscale <- m1$.__enclos_env__[["private"]][[".multiscale"]]

## Get critical overlap values
g <- local({
  d <- ncol(m1$cover$filter_values)
  base_interval_length <- apply(apply(m1$cover$filter_values, 2, range), 2, diff)/m1$cover$number_intervals
  g <- lapply(1:d, function(d_i) 1 - base_interval_length[d_i]/multiscale$filt_dist[[d_i]])
  lapply(g, function(g_) g_ + .Machine$double.eps)
})

## Ensure computed interval sizes match the recorded ones 
for (d_i in 1:d){
  local({
    r_ref <- environment(m1$update_mapper)[["interval_sizes"]][[d_i]]
    r_com <- base_interval_length[[d_i]] + (base_interval_length[[d_i]]*g[[d_i]])/(1.0-g[[d_i]])
    print(all(abs(r_ref - r_com) < sqrt(.Machine$double.eps)))
  })
}

## Randomized approach 
# all_possible_mappers <- as.matrix(expand.grid(g))
# params <- all_possible_mappers[sample(1:nrow(all_possible_mappers), size = 100, replace = FALSE),]

## Sequential approach
params <- do.call(cbind, g)
# params <- params[params[, 1] < 0.50 & params[, 2] < 0.50,]

checks <- list(valid=NULL, equal=NULL)
params_to_test <- lapply(1:nrow(params), function(i) params[i,])
params_to_test <- params_to_test[sample(1:length(params_to_test), size = 100, replace = FALSE)]
# params_to_test <- rev(lapply(1:nrow(params), function(i) params[i,]))
for (g_i in params_to_test){
  # if (all(abs(g_i - bad) < sqrt(.Machine$double.eps))){
  #   browser()
  # }
  
  ## Update the first mapper 
  m1$update_mapper(g_i) 
  
  ## Update the second mapper 
  m2$cover$percent_overlap <- g_i
  m2$cover$construct_cover()
  m2$compute_k_skeleton(k = 1L)
  
  ## Check validity + equivalence w/ naive mapper 
  checks$valid <- c(checks$valid, validity_check(m1))
  checks$equal <- c(checks$equal, check_mappers(m1, m2))
  
  # readline(prompt = "Press enter to continue...")
  
  if (any(!checks$valid) || any(!checks$equal)){
    break
    # ## Visual debugging
    # # plot_1D(d_i = 1, percent_overlap = g_i, m = m1, discrete = FALSE)
    # plot_2D(m1, g = g_i, pt_ids = TRUE)
    # # readline(prompt = "Press enter to continue...")
    # browser()
  }
}
table(unlist(m1$vertices))
table(unlist(m2$vertices))


plot(m1$cover$filter_values)
text(m1$cover$filter_values, labels = 1:nrow(m1$cover$filter_values), pos = 3)

## Go backwards
checks <- list(valid=NULL, equal=NULL)
for (i in length(g):1){
  g_i <- g[i]
  
  ## Update the first mapper 
  m1$update_mapper(g_i) 
  
  ## Update the second mapper 
  m2$cover$percent_overlap <- g_i
  m2$cover$construct_cover()
  m2$compute_k_skeleton(k = 1L)
  
  ## Check validity + equivalence w/ naive mapper 
  checks$valid <- c(checks$valid, validity_check(m1))
  checks$equal <- c(checks$equal, check_mappers(m1, m2))
  
  ## Visual debugging
  #plot_1D(d_i = 1, percent_overlap = g_i, m = m1, discrete = FALSE)
  #readline(prompt = "Press enter to continue...")
}



plot_1D(1, percent_overlap = 0.20, m = m1, discrete = FALSE)

## M1s
invisible(mapply(function(v, id) { 
  v_ls <- attr(v, "level_set")
  cat(sprintf("%d (ls=%d): %s\n", id, v_ls, paste0(v, collapse = ",")))
}, m1$vertices, 1:length(m1$vertices)))

## M2
invisible(mapply(function(v, id) { 
  v_ls <- attr(v, "level_set")
  cat(sprintf("%d (ls=%d): %s\n", id, v_ls, paste0(v, collapse = ",")))
}, m2$vertices, 1:length(m2$vertices)))


## Test the inverse works...
test_g <- seq(0.05, 0.95, by = 0.05)
r <- base_interval_length + (base_interval_length*test_g)/(1-test_g)
all((test_g - (1 - base_interval_length/r)) < sqrt(.Machine$double.eps))

```

```{r}
## Auxillaury variables needed 
percent_overlap <- 0.05

## LS Multi-indices == Cartesian product of the intervals
cart_prod <- arrayInd(seq(prod(m$cover$number_intervals)), .dim = m$cover$number_intervals)

## Get filter min and max ranges
filter_rng <- apply(m$cover$filter_values, 2, range)
{ filter_min <- filter_rng[1,]; filter_max <- filter_rng[2,] }
filter_len <- diff(filter_rng)
    
## Get the bounds associated with the level sets 
base_interval_length <- filter_len/m$cover$number_intervals
interval_length <- base_interval_length + (base_interval_length * percent_overlap)/(1.0 - percent_overlap)
eps <- interval_length/2.0
ls_bnds <- t(apply(cart_prod, 1, function(idx){
  centroid <- filter_min + ((as.integer(idx)-1L)*base_interval_length) + base_interval_length/2.0
  c(centroid - eps, centroid + eps)
}))
```


```{r}
filter_values <- matrix(f_x[1:10,])

m$enable_multiscale()

plot_1D(d_i = 1, percent_overlap = 0, m = m)
multiscale$extract_level_set(0)

animation::saveGIF({
  for (g_i in seq(0, 0.995, by = 0.005)){
    plot_1D(d_i = 1, percent_overlap = g_i, m = m, discrete = FALSE)
  }
}, movie.name = "continuous_expansion.gif", interval = 0.2, ani.width = 480*2, ani.height = 480)

animation::saveGIF({
  for (g_i in seq(0, 0.995, by = 0.005)){
    plot_1D(d_i = 1, percent_overlap = g_i, m = m, discrete = TRUE)
  }
}, movie.name = "discrete_expansion.gif", interval = 0.2, ani.width = 480*2, ani.height = 480)

## Function to plot the filter space
plot_1D <- function(d_i, percent_overlap, m, discrete = TRUE){
  make_square <- function(x, y, ...){ rect(xleft = x[1], xright = x[2], ybottom = y[1], ytop = y[2], ...) }
  multiscale <- m$.__enclos_env__[["private"]][[".multiscale"]]
  filter_values <- m$cover$filter_values
  filter_rng <- apply(filter_values, 2, range)
  { filter_min <- filter_rng[1,]; filter_max <- filter_rng[2,] }
  filter_len <- diff(filter_rng)
  base_interval_length <- filter_len/m$cover$number_intervals
  
  ## Retrieve the nearest filtration index
  r <- base_interval_length + (base_interval_length*percent_overlap)/(1-percent_overlap)
  if (discrete){
    idx <- multiscale$get_nearest_filtration_index(c(r))
    interval_length <- ifelse(idx == -1, base_interval_length, multiscale$filt_dist[[d_i]][idx+1L])
    eps <- interval_length/2
  } else {
    interval_length <- r
    eps <- interval_length/2
  }
  

  ## Construct the level set endpoints 
  d <- ncol(m$cover$filter_values)
  ni <- m$cover$number_intervals
  ls_endpts <- lapply(1L:d, function(d_i){
    tmp <- as.vector(sapply(0L:(ni[d_i] - 1L), function(ls_i){
      centroid <- filter_min[d_i] + (as.integer(ls_i)*base_interval_length[d_i]) + base_interval_length[d_i]/2.0
      c(centroid - eps, centroid + eps)
    }))
    matrix(tmp, ncol = 2, byrow = TRUE)
  })

  plot(filter_values[, d_i], rep(0, nrow(filter_values)), pch = 20, ylim = c(-0.75, 0.75), xlab = "", ylab = "", yaxt = "n")
  text(filter_values[, d_i], 0, labels = 1:nrow(filter_values), pos = 3)
  abline(h = 0, col = "gray", lty = 3, lwd = 1.5)
  binned_color <- rev(rainbow(nrow(ls_endpts[[d_i]]), start = 0, end = 4/6))
  segment_color <- rev(rainbow(nrow(ls_endpts[[d_i]])*2, start = 0, end = 4/6))
  cc <- 0L
  cls <- ls_endpts[[d_i]]
  c_alpha <- 0.90
  for (i in 1:nrow(cls)){
    ls <- cls[i, ]
    if (i %in% c(1, nrow(cls))){
      if (i == 1){
        {
          line_density <- ifelse(cc %% 2 == 0, 0, 10)
          xx <- c(ls[1], cls[i+1L, 1L])
          lines(x = xx, y = rep(0.51, 2))
          text(x = mean(xx), y = 0.5, pos = 3, labels = as.character(cc), col = segment_color[cc+1])
          make_square(x = xx, y = c(-0.5, 0.5), col = adjustcolor(segment_color[cc+1], alpha.f = c_alpha), 
                      density = line_density)
        }
        cc <- cc + 1
        { 
          line_density <- ifelse(cc %% 2 == 0, 0, 10)
          xx <- c(cls[i+1L, 1L], ls[2])
          lines(x = xx, y = rep(0.51, 2))
          text(x = mean(xx), y = 0.5, pos = 3, labels = as.character(cc), col = segment_color[cc+1])
          make_square(x = xx, y = c(-0.5, 0.5), col = adjustcolor(segment_color[cc+1], alpha.f = c_alpha), 
                      density = line_density)
        }
        cc <- cc + 1
      }
      else if (i == nrow(cls)){
        line_density <- ifelse(cc %% 2 == 0, 0, 10)
        xx <- c(cls[i-1L, 2L], ls[2])
        lines(x = xx, y = rep(0.51, 2))
        text(x = mean(xx), y = 0.5, pos = 3, labels = as.character(cc), col = segment_color[cc+1])
        make_square(x = xx, y = c(-0.5, 0.5), col = adjustcolor(segment_color[cc+1], alpha.f = c_alpha), 
                    density = line_density)
        cc <- cc + 1
      }
    } else {
      {
        line_density <- ifelse(cc %% 2 == 0, 0, 10)
        xx <- c(cls[i-1L, 2L], cls[i+1L, 1L])
        lines(x = xx, y = rep(0.51, 2))
        text(x = mean(xx), y = 0.5, pos = 3, labels = as.character(cc), col = segment_color[cc+1])
        make_square(x = xx, y = c(-0.5, 0.5), col = adjustcolor(segment_color[cc+1], alpha.f = c_alpha), 
                    density = line_density)
      }
      cc <- cc + 1
      {
        line_density <- ifelse(cc %% 2 == 0, 0, 10)
        xx <- c(cls[i+1L, 1L], ls[2])
        lines(x = c(cls[i+1L, 1L], ls[2]), y = rep(0.51, 2))
        text(x = mean(c(cls[i+1L, 1L], ls[2])), y = 0.5, pos = 3, labels = as.character(cc), col = segment_color[cc+1])
        make_square(x = xx, y = c(-0.5, 0.5), col = adjustcolor(segment_color[cc+1], alpha.f = c_alpha), 
                    density = line_density)
      }
      cc <- cc + 1
    }

    lines(x = c(ls[1], ls[2]), y = c(-0.5, -0.5), col = binned_color[i])
    lines(x = c(ls[2], ls[2]), y = c(-0.5, 0.5), col = binned_color[i])
    lines(x = c(ls[2], ls[1]), y = c(0.5, 0.5), col = binned_color[i])
    lines(x = c(ls[1], ls[1]), y = c(0.5, -0.5), col = binned_color[i])
    text(labels = as.character(i - 1L), x = mean(c(ls[1], ls[2])), y = -0.5, col = binned_color[i], pos = 1)
    points(x = mean(c(ls[1], ls[2])), y = 0, pch = 3, col = binned_color[i])
    i <- i + 1
  }
  text(x = cls[nrow(cls), 2L], y = 0.5, pos = 3, labels = as.character(cc))
  points(filter_values[, d_i], rep(0, nrow(filter_values)), pch = 20)
  # if (idx > 0){
  #   points(filter_values[pt_idx[[d_i]][idx], d_i], 0, pch = 21, cex = 1.5, col = "purple")
  # }
  text(filter_values[, d_i], 0, labels = 1:nrow(filter_values), pos = 3)
}
```

```{r}
plot_2D <- function(m, g, prev=NULL, pt_ids = FALSE){
  # make_square <- function(x, y, ...){ rect(xleft = x[1], xright = x[2], ybottom = y[1], ytop = y[2], ...) }
  make_square <- function(x, y, ...){
   lines(x = c(x[1], x[2]), y = c(y[1], y[1]), ...)
   lines(x = c(x[2], x[2]), y = c(y[1], y[2]), ...)
   lines(x = c(x[2], x[1]), y = c(y[2], y[2]), ...)
   lines(x = c(x[1], x[1]), y = c(y[2], y[1]), ...)
  }
  dist_to_ls <- environment(m1$update_mapper)[["dist_to_ls"]]
  dist_order <- environment(m1$update_mapper)[["dist_order"]]
  filter_dim <- ncol(m$cover$filter_values)
  cart_prod <- arrayInd(seq(prod(m$cover$number_intervals)), .dim = m$cover$number_intervals)
  filter_rng <- apply(m$cover$filter_values, 2, range)
  { filter_min <- filter_rng[1,]; filter_max <- filter_rng[2,] }
  filter_len <- diff(filter_rng)
  number_intervals <- m$cover$number_intervals
  base_interval_length <- filter_len/m$cover$number_intervals
  interval_length <- base_interval_length + (base_interval_length * g)/(1.0 - g)
  eps <- interval_length/2.0
  ls_bnds <- t(apply(cart_prod, 1, function(idx){
    centroid <- filter_min + ((as.integer(idx)-1L)*base_interval_length) + base_interval_length/2.0
    c(centroid - eps, centroid + eps)
  }))
  ls_endpts <- lapply(1L:filter_dim, function(d_i){
    ## Choose the interval (half) width to plot
    if (g[d_i] == 0){ eps <- (base_interval_length[[d_i]]/2) } 
    else {
      eps <- (base_interval_length[[d_i]] + ((base_interval_length[[d_i]]*g[d_i])/(1 - g[d_i])))/2 # parameterized overlap
    }
    tmp <- as.vector(sapply(0L:(number_intervals[d_i] - 1L), function(idx){
      centroid <- filter_min[d_i] + (as.integer(idx)*base_interval_length[d_i]) + base_interval_length[d_i]/2.0
      c(centroid - eps, centroid + eps)
    }))
    matrix(tmp, ncol = 2, byrow = TRUE)
  })
  get_range <- function(x) { tmp <- range(x); tmp + c(-diff(tmp)*.10, diff(tmp)*.10) }
  plot(m$cover$filter_values, pch = 20,
       xlim = get_range(m$cover$filter_values[, 1L]), ylim = get_range(m$cover$filter_values[, 2L]),
       xlab = "", ylab = "") # xaxt = "n", yaxt = "n"
  if (pt_ids){ text(m$cover$filter_values, labels = 1:nrow(m$cover$filter_values), pos = 3) }
  #
  # abline(h = 0, col = "gray", lty = 3, lwd = 1.5)
  # binned_color <- rev(rainbow(length(m$cover$index_set), start = 0, end = 4/6))# , alpha.f = 0.00)
  binned_color <- viridis::plasma(length(m$cover$index_set))
  cc <- 0L
  for (i in 1:nrow(cart_prod)){
    { ii <- cart_prod[i,1]; jj <- cart_prod[i,2] }
    { cls1 <- ls_endpts[[1]]; cls2 <- ls_endpts[[2]] }
    col <- binned_color[which(m$cover$index_set == paste0("(", paste(ii, jj), ")"))]
    make_square(cls1[ii,], cls2[jj,], col = col, lwd = 2)
    points(x = mean(cls1[ii,]), y = mean(cls2[jj,]), col = col, pch = 3)
    text(x = mean(cls1[ii,]), y = mean(cls2[jj,]), labels = trimws(paste0(c(ii, jj) - 1L, collapse = ",")), cex = 0.50, pos = 1)
  }
  # for (d_i in 1:filter_dim){
  #   # browser()
  #   if (idx[[d_i]] > 0){
  #     pt <- pt_idx[[d_i]][[idx[[d_i]]]]
  #     points(x = filter_values[pt,1], y = filter_values[pt,2], col = "purple")
  #   }
  # }
  if (!missing(prev)){
    # browser()
    ls_changed <- ms_mapper$get_ls_that_change(prev, idx)+1
    if (nrow(ls_changed) > 0){
      apply(ls_changed, 1, function(x) {
        ls1 <- lsmi[x[1], ]
        ls2 <- lsmi[x[2], ]
        rect(xleft = ls_endpts[[1]][ls1[1],1], xright = ls_endpts[[1]][ls1[1],2],
             ybottom = ls_endpts[[2]][ls1[2],1], ytop = ls_endpts[[2]][ls1[2],2],
             col = rgb(0.8, 0, 0.8, alpha = 0.3))
        rect(xleft = ls_endpts[[1]][ls2[1],1], xright = ls_endpts[[1]][ls2[1],2],
             ybottom = ls_endpts[[2]][ls2[2],1], ytop = ls_endpts[[2]][ls2[2],2],
             col = rgb(0.8, 0, 0.8, alpha = 0.3))
      })
    }
  }
}
```


```{r}


v1 <- lapply(seq(0.05, 0.50, by = 0.05), function(g){
  m$cover$percent_overlap <- g
  m$cover$construct_cover()
  m$compute_k_skeleton(k = 1L)
  m$simplicial_complex$as_edge_list()
})

m$enable_multiscale()
m$update_mapper(c(0.25))

v2 <- lapply(seq(0.05, 0.50, by = 0.05), function(g){
  m$update_mapper(g)
  m$simplicial_complex$as_edge_list()
})


m$compute_vertices(which_levels = m$cover$index_set[3:4])
```


