---
title: "Multiscale Benchmarks"
output: html_notebook
---
```{r}

compute_multiscale <- function(mapper, g){
  d <- ncol(mapper$cover$filter_values)
  mapper$enable_multiscale() 
  mapper$update_mapper(rep(0, d))
  
  ## Get the overlap values
  lapply(g, function(g_i){
    mapper$update_mapper(rep(g_i, d), stats = TRUE)
  })
}



ls1 <- sapply(seq(length(mapper$cover$level_sets))-1L, function(i){
  multiscale$extract_level_set(i)
})


# wut <- FixedRectangularCover$new(filter_values = cbind(1:10, 1:10, 1:10))
# wut$number_intervals <- 3
# wut$percent_overlap <- 5
# bnds <- wut$level_set_bounds()
# idx <- expand.grid(1:3, 1:3, 1:3)
# sapply(1:nrow(idx), function(i) bnds[]
# rgl::points3d(bnds[,1:3])
```

```{r}
## Benchmark
bench_mapper <- function(mapper_f, g_card) {
  lapply(g_card, function(degree){
  
    ## Get a new mapper
    m <- mapper_f()
    multiscale <- m$.__enclos_env__[["private"]][[".multiscale"]]
    
    ## Get the overlap values 
    if (is.numeric(degree)){
      ## How good of an approximation to the multiscale mapper is wanted
      g <- replicate(ncol(m$cover$filter_values), seq(0, 50, length.out = degree))
    } else if (degree == "exact"){
      env <- environment(m$update_mapper)
      r_len <- env[["base_interval_length"]]
      g <- do.call(cbind, lapply(multiscale$filt_dist, function(r_x) as.vector(1) - as.vector(r_len)/r_x))
      g <- g[apply(g, 1, function(g_i) all(g_i < 0.50)),,drop = FALSE]*100
    }
  
    ## Cumulative number of edges need to be computed
    cum_num_edges <- apply(g, 1, function(g_i){
      print(g_i)
      
      ## Worst case -- no knowledge
      worst_case <- choose(prod(m$cover$number_intervals), 2)
      
      ## Bounded case 
      bounded_cover <- m$cover$clone()
      bounded_cover$percent_overlap <- g_i
      bounded_case <- nrow(bounded_cover$level_sets_to_compare())
      
      ## Our approach
      tmp <- m$update_mapper(rep(g_i, ncol(m$cover$filter_values)), stats = TRUE)
      optimal_case <- nrow(tmp$updated_ls_pairs)
      
      list(worst_case, bounded_case, optimal_case)
    })
    
    ## Accumulate the results
    data.frame(resolution=degree, apply(do.call(rbind, cum_num_edges), 2, cumsum), percent_overlap=g)
  })
}
```

```{r}
## Diabetes data from the original paper + KDE 
X <- apply(chemdiab[, 1:5], 2, function(x) scale(x, center = FALSE))
f_x <- ks::kde(X, H = diag(5), eval.points = X, verbose = FALSE)$estimate

## Diabetes mapper
diab_mapper <- function(){
  MapperRef$new(X = X)$
  use_cover(filter_values = matrix(f_x), typename = "fixed rectangular", number_intervals = 4L, percent_overlap = 0)$
  use_distance_measure(measure = "euclidean")$
  use_clustering_algorithm(cl = "single", num_bins = 15L)$
  compute_k_skeleton(k = 1L)$
  enable_multiscale() ## enables multiscale mapper
}

## The discrete approximations to make
g_card <- list(10, 50, "exact")
bench_res <- bench_mapper(diab_mapper, g_card)
tmp <- do.call(rbind, bench_res)
colnames(tmp) <- c("degree", "Brute Force", "Bounded Approach", "Indexed Approach", "percent_overlap")

## ggplot has a poorly designed interface.
agg_res <- data.table::melt(tmp, id.vars = c("degree", "percent_overlap"), measure.vars=colnames(tmp)[2:4])
type <- sprintf("%s-%s", as.character(agg_res$variable), agg_res$degree)
bench_data <- data.frame(type, agg_res$percent_overlap, agg_res$value)
colnames(bench_data) <- c("approx_type", "percent_overlap", "pairs")
bench_data[["method"]] <- agg_res$variable
bench_data[["approx_degree"]] <- agg_res$degree

ggplot2::ggplot(data = bench_data, aes(x=percent_overlap, group=approx_type, fill=approx_degree, color=method)) +
  geom_line(mapping = aes(y=log(pairs), linetype=approx_degree, color=method), size=0.80) + 
  scale_linetype_manual(values=c("11", "dashed", "solid"), name=expression(n, "-approximation"))+
  scale_color_manual(values=c("red", "green", "orange"), name = "ss")
  geom_line(mapping = aes(y=log(pairs), color=method), size=0.80)
    +
    guides(fill = guide_legend(title='vdf color'), color = guide_legend(title='vdf color'))
  guide_legend()
  scale_color_discrete(guide = guide_legend())

linetypes <- c("dotted", "dashed", "solid")
library("ggplot2")
ggplot2::ggplot(data = agg_res, aes(x=percent_overlap, group=degree, fill=variable)) +
  geom_line(mapping = aes(y=log(pairs), linetype=approx_type), color="red", size=0.80) +  
    scale_linetype_manual(values=rep(linetypes, 3), name="group")+
    guides(fill=guide_legend(override.aes=list(linetype=rep(linetypes, 3))))
  geom_line(mapping = aes(y=log(`Bounded Approach`), linetype=degree), color="blue", size=0.80) +
  geom_line(mapping = aes(y=log(`Indexed Approach`), linetype=degree), color="green", size=0.80)+
  scale_linetype_manual(values=linetypes)+
  theme(legend.position="right") + theme_bw() + 
  xlab("Percent Overlap") + ylab("Cumulative # Intersection Comparisons")+ 
  ggtitle("Computing mapper at multiple scales") +
  scale_linetype_manual(values=linetypes, guide = guide_legend(override.aes = list(shape = 22, size = 5)))

```

```{r}
## Diabetes data from the original paper + KDE 
library("Mapper")

## World Values Survey 
load("/Users/mpiekenbrock/Downloads/WV6_Data_R_v_2016_01_01.rdata")
WV_survey <- data.table::data.table(WV6_Data_R)
WV_US <- WV_survey[V2 == 840]

key_vals <- c(V4="FamilyImportance", V5="FriendImportance", V7="PoliticsImportance", V8="WorkImportance", 
              V9="ReligionImportance", V10="Happiness", V11="Health", V23="Satisfied", V24="TrustInOthers", 
              V25="ReligiousMember", V29="PoliticsMember", V30="EnvironMember", V32="CharityMember", 
              V55="ControlOverLife", V56="TakeAdvantageOf", V57="MarriedStatus", V58="NumChildren", 
              V59="FinancialSatisfaction", V60="CountryAimsFirstChoice", V61="CountryAimsSecondChoice", 
              V67="FutureWorkEmphasis", V68="FutureTechnologyEmphasis", V69="FutureRespectAuthority", 
              V84="InterestInPolitics", V95="PoliticalLeaning", V97="OwnershipOfBusiness", V98="BeliefInCompetition", 
              V101="BeliefOnWealth")

WV_US_subset <- WV_US[,.SD, .SDcols = names(key_vals)]
normalize <- function(x){ (x - min(x))/(max(x) - min(x)) }
WV_US_normed <- apply(WV_US_subset, 2, normalize)
WV_US_nice <- WV_US_subset
colnames(WV_US_nice) <- key_vals

wv_ica <- fastICA::fastICA(as.matrix(WV_US_nice), n.comp = 2, method = "C", alg.typ = "deflation", row.norm = TRUE)

new_mapper <- function(){
  Mapper:::MapperRef$new(as.matrix(WV_US_nice))$
  use_cover(filter_values=wv_ica$S, type="fixed rectangular", number_intervals=10L, percent_overlap=0)$
  use_distance_measure(measure = "euclidean")$
  use_clustering_algorithm(cl = "single", num_bins = 10L)$
  compute_k_skeleton(k = 1L)$
  enable_multiscale() ## enables multiscale mapper
}

## The discrete approximations to make
g_card <- list(10, 100, "exact")

## Benchmark results
bench_res <- lapply(g_card, function(degree){
  
  ## Get a new mapper
  m <- new_mapper()
  multiscale <- m$.__enclos_env__[["private"]][[".multiscale"]]
  
  ## Get the overlap values 
  d <- ncol(m$cover$filter_values)
  if (is.numeric(degree)){
    ## How good of an approximation to the multiscale mapper is wanted
    g <- replicate(d, seq(0, 50, length.out = degree))
  } else if (degree == "exact"){
    env <- environment(m$update_mapper)
    r_len <- env[["base_interval_length"]]
    g <- do.call(cbind, lapply(1:d, function(d_i) as.vector(1) - as.vector(r_len[[d_i]])/multiscale$filt_dist[[d_i]]))
    g <- g[apply(g, 1, function(g_i) all(g_i < 0.50)),,drop = FALSE]*100
  }
  
  ## Cumulative number of edges need to be computed
  cum_num_edges <- apply(g, 1, function(g_i){
    print(g_i)
    
    ## Worst case -- no knowledge
    worst_case <- choose(prod(m$cover$number_intervals), 2)
    
    ## Bounded case 
    bounded_cover <- m$cover$clone()
    bounded_cover$percent_overlap <- g_i
    bounded_case <- nrow(bounded_cover$level_sets_to_compare())
    
    ## Our approach
    tmp <- m$update_mapper(g_i, stats = TRUE)
    optimal_case <- nrow(tmp$updated_ls_pairs)
    
    list(worst_case, bounded_case, optimal_case)
  })
  
  ## Accumulate the results
  res <- data.frame(resolution=degree, 
                    apply(do.call(rbind, cum_num_edges), 2, cumsum), 
                    percent_overlap=g)
  return(res)
})

tmp <- do.call(rbind, bench_res)
colnames(tmp) <- c("degree", "Brute Force", "Bounded Approach", "Indexed Approach", "percent_overlap")

# agg_res <- data.table::melt(tmp, id.vars = c("degree", "percent_overlap"), measure.vars=colnames(tmp)[2:4])
linetypes <- c("dotted", "dashed", "solid")
library("ggplot2")
ggplot2::ggplot(data = tmp, aes(x=percent_overlap, group=degree)) +
  geom_line(mapping = aes(y=log(`Brute Force`), linetype=degree), color="red", size=0.8) +    
  geom_line(mapping = aes(y=log(`Bounded Approach`), linetype=degree), color="blue", size=0.8) +
  geom_line(mapping = aes(y=log(`Indexed Approach`), linetype=degree), color="green", size=0.8)+
  scale_linetype_manual(values=linetypes)+
  theme(legend.position="right")
```



```{r}
crater <- as.matrix(readr::read_table(file = "~/Downloads/crater.xy.txt", col_names = FALSE))

```


```{r}
g <- igraph::graph_from_adjacency_matrix(m$simplicial_complex$as_adjacency_matrix(), mode = "undirected", add.colnames = NA)

library(RColorBrewer)
diabetic_colors <- colorRamp(c("red", "white", "green"))(cbind(c(0, 0), c(1, 1)))
diabetic_colors
v_col <- sapply(names(m$vertices), function(vid) mean(as.integer(chemdiab$cc)[m$vertices[[vid]]]))+1

plot(g, vertex.color = palette()[v_col])
?igraph::plot.igraph

# gtour(flea[1:6], flea[[7]])
# gtour(olive[3:10], olive[[1]])
gtour(chemdiab[,1:5], as.integer(chemdiab$cc))
```

```{r}
library(shiny)
library(ggvis)
library(tourr)
gtour <- function(data, groups) {
  aps <- 2
  fps <- 30
  mat <- rescale(as.matrix(data))
  tour <- new_tour(mat, grand_tour(), NULL)
  start <- tour(0)
  proj_data <- reactive({
    invalidateLater(1000 / fps, NULL);
    step <- tour(aps / fps)
    data.frame(center(mat %*% step$proj), groups = groups)
  })
  proj_data %>% ggvis(~X1, ~X2, fill = ~groups) %>%
    layer_points() %>%
    scale_numeric("x", domain = c(-1, 1)) %>%
    scale_numeric("y", domain = c(-1, 1)) %>%
    add_axis("x", title = "") %>% add_axis("y", title = "") %>%
    set_options(duration = 0)
}

